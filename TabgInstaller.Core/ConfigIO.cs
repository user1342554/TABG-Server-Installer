using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using TabgInstaller.Core.Model;
using Newtonsoft.Json;

namespace TabgInstaller.Core
{
    public static class ConfigIO
    {
        public static GameSettingsData ReadGameSettings(string filePath)
        {
            var obj = new GameSettingsData();
            if (!File.Exists(filePath)) return obj;

            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
            foreach (var raw in File.ReadAllLines(filePath))
            {
                var line = raw.Trim();
                if (string.IsNullOrWhiteSpace(line) || line.StartsWith("//")) continue;
                var idx = line.IndexOf('=');
                if (idx < 1) continue;
                var key = line.Substring(0, idx).Trim();
                var value = line.Substring(idx + 1).Trim();
                dict[key] = value;
            }

            var props = typeof(GameSettingsData).GetProperties();
            foreach (var p in props)
            {
                if (!dict.TryGetValue(p.Name, out var rawValue)) continue;
                    try
                    {
                        object? converted = p.PropertyType switch
                        {
                        Type t when t == typeof(string) => rawValue,
                        Type t when t == typeof(int) => int.Parse(rawValue, CultureInfo.InvariantCulture),
                        Type t when t == typeof(float) => float.Parse(rawValue, CultureInfo.InvariantCulture),
                        Type t when t == typeof(bool) => bool.Parse(rawValue),
                        _ => null
                        };
                    if (converted != null)
                    {
                        p.SetValue(obj, converted);
                    }
                }
                catch
                {
                    // ignore malformed values â€“ the default remains
                }
            }
            return obj;
        }

        public static void WriteGameSettings(GameSettingsData data, string filePath)
        {
            // Read existing file to preserve order, comments and unknown keys
            var existingLines = File.Exists(filePath) ? File.ReadAllLines(filePath).ToList() : new List<string>();
            // If the file did not have our generator header yet, add it later

            bool hadHeader = existingLines.Count>0 && existingLines[0].StartsWith("// game_settings.txt");

            var lines = hadHeader ? existingLines : new List<string>(existingLines)
            {
                // ensure header at top once
            };
            if(!hadHeader)
            {
                lines.Insert(0,"// game_settings.txt generated by TabgInstaller");
            }

            // Desired order of properties in the output file
            string[] order =
            {
                "ServerName",
                "ServerDescription",
                "Port",
                "MaxPlayers",
                "Relay",
                "AutoTeam",
                "Password",
                "CarSpawnRate",
                "UseTimedForceStart",
                "ForceStartTime",
                "MinPlayersToForceStart",
                "PlayersToStart",
                "Countdown",
                "RingSizes",
                "AllowRespawnMinigame",
                "TeamMode",
                "GameMode",
                "AntiCheat"
            };

            // Map of comment lines that should precede each property (if any)
            var comments = new Dictionary<string,string>
            {
                {"ServerName", "// Name of the server"},
                {"ServerDescription", "// Server Description"},
                {"Port", "//Port To Use"},
                {"MaxPlayers", "// max players on server. Max being 253"},
                {"Relay", "//Use Relay"},
                {"AutoTeam", "// server wide auto teaming"},
                {"Password", "//Password"},
                {"CarSpawnRate", "// 0.0 - 1.0 percentage of cars to spawn. 0 being 0% and 1 being 100%. "},
                {"UseTimedForceStart", "// Will start match with fewer then PlayersToStart if waited longer then ForceStartTime"},
                {"ForceStartTime", "// Seconds until force start the countdown"},
                {"MinPlayersToForceStart", "// Players needed to start the force start timer"},
                {"PlayersToStart", "// Players to start countdown"},
                {"Countdown", "// Seconds it takes to start the game after Players have joined or force start triggered"},
                {"RingSizes", "//default sizes are: RingSizes=4240.0,3450.0,1710.0,830.0,360.0,140.0"},
                {"AllowRespawnMinigame", "// enable or disable the respawn minigame."},
                {"TeamMode", "// SQUAD, DUO or SOLO"},
                {"GameMode", "//\n// Ehm..  Have fun"},
                {"AntiCheat", "//Leave This To False"}
            };

            var propsDict = typeof(GameSettingsData).GetProperties()
                .ToDictionary(p => p.Name, p => p.GetValue(data));

            // Ensure header lines exist only once
            void EnsureSingleLine(string header)
            {
                int idx = lines.FindIndex(l => l.Trim().Equals(header, StringComparison.OrdinalIgnoreCase));
                if (idx == -1) lines.Insert(0, header);
                else
                {
                    // remove duplicates afterwards
                    for (int i = lines.Count - 1; i > idx; i--)
                    {
                        if (lines[i].Trim().Equals(header, StringComparison.OrdinalIgnoreCase)) lines.RemoveAt(i);
                    }
                }
            }

            EnsureSingleLine("// game_settings.txt generated by TabgInstaller");
            EnsureSingleLine("// Allowed word list for name / description: https://github.com/landfallgames/tabg-word-list");

            // Helper to format value
            static string ToInvariant(object val) => val switch
            {
                float f => f.ToString(CultureInfo.InvariantCulture),
                int i => i.ToString(CultureInfo.InvariantCulture),
                bool b => b.ToString().ToLowerInvariant(),
                _ => val.ToString() ?? string.Empty
            };

            // Update or insert lines for each known key in desired order
            foreach (var key in order)
            {
                if (!propsDict.TryGetValue(key, out var val) || val == null) continue;

                // Skip empty strings or false bool exclusions
                if (val is string s && string.IsNullOrEmpty(s)) continue;
                if (key == "UseSouls" && val is bool b1 && !b1) continue;
                if (key == "UseKicks" && val is bool b2 && !b2) continue;
                if (key == "AllowRejoins" && val is bool b3 && !b3) continue;

                string newLine = $"{key}={ToInvariant(val)}";

                // Try find existing line for this key (ignoring whitespace)
                int existingIdx = lines.FindIndex(l => !l.TrimStart().StartsWith("//") && l.Split('=')[0].Trim().Equals(key, StringComparison.OrdinalIgnoreCase));

                if (existingIdx >= 0)
                {
                    // replace
                    lines[existingIdx] = newLine;
                }
                else
                {
                    // insert at end with optional comment
                    if (comments.TryGetValue(key, out var cmt)) lines.Add(cmt);
                    lines.Add(newLine);
                }
            }

            // Remove any duplicate empty lines
            for (int i = lines.Count - 2; i >= 0; i--)
            {
                if (string.IsNullOrWhiteSpace(lines[i]) && string.IsNullOrWhiteSpace(lines[i + 1]))
                    lines.RemoveAt(i + 1);
            }

            File.WriteAllLines(filePath, lines);
        }

        public static TheStarterPackConfig ReadStarterPack(string filePath)
        {
            if (!File.Exists(filePath))
                return new TheStarterPackConfig();
            try
            {
                var json = File.ReadAllText(filePath);
                var obj = JsonConvert.DeserializeObject<TheStarterPackConfig>(json);
                return obj ?? new TheStarterPackConfig();
            }
            catch
            {
                return new TheStarterPackConfig();
            }
        }

        public static void WriteStarterPack(TheStarterPackConfig cfg, string filePath)
        {
            var json = JsonConvert.SerializeObject(cfg, Formatting.Indented);
            File.WriteAllText(filePath, json);
        }

        // -------- CitrusLib ExtraSettings --------
        public static Dictionary<string,string> ReadExtraSettings(string filePath)
        {
            if (!File.Exists(filePath)) return new Dictionary<string,string>();
            try
            {
                var json = File.ReadAllText(filePath);
                var dict = JsonConvert.DeserializeObject<Dictionary<string,string>>(json);
                return dict ?? new Dictionary<string,string>();
            }
            catch { return new Dictionary<string,string>(); }
        }

        public static void WriteExtraSettings(Dictionary<string,string> dict, string filePath)
        {
            Directory.CreateDirectory(Path.GetDirectoryName(filePath)!);
            var json = JsonConvert.SerializeObject(dict, Formatting.Indented);
            File.WriteAllText(filePath, json);
        }

        // -------- PlayerPerms --------
        public static List<string> ReadPlayerPerms(string filePath)
        {
            if (!File.Exists(filePath)) return new List<string>();
            try
            {
                var json = File.ReadAllText(filePath);
                var list = JsonConvert.DeserializeObject<List<string>>(json);
                return list ?? new List<string>();
            }
            catch { return new List<string>(); }
        }

        public static void WritePlayerPerms(List<string> list, string filePath)
        {
            var json = JsonConvert.SerializeObject(list, Formatting.Indented);
            File.WriteAllText(filePath, json);
        }
    }
} 